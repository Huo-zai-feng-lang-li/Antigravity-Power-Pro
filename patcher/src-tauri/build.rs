use std::{
    collections::HashSet,
    env,
    fs,
    path::{Path, PathBuf},
};

fn main() {
    tauri_build::build();

    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("Missing CARGO_MANIFEST_DIR"));
    let patches_dir = manifest_dir.join("..").join("patches");
    let exclude_path = patches_dir.join(".embed-exclude.txt");

    let exclude = read_exclude_list(&exclude_path);
    let mut files: Vec<(String, String)> = Vec::new();
    collect_patch_files(&patches_dir, &patches_dir, &exclude, &mut files);
    expand_shared_files(&patches_dir, &exclude, &mut files);
    files.sort();

    let output = render_embedded_list(&files);
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("Missing OUT_DIR"));
    let out_path = out_dir.join("embedded_patches.rs");
    fs::write(&out_path, output).expect("Failed to write embedded patches list");

    println!("cargo:rerun-if-changed={}", patches_dir.display());
    println!("cargo:rerun-if-changed={}", exclude_path.display());
}

fn read_exclude_list(path: &Path) -> HashSet<String> {
    let mut entries = HashSet::new();
    entries.insert(".embed-exclude.txt".to_string());

    let content = match fs::read_to_string(path) {
        Ok(content) => content,
        Err(_) => return entries,
    };

    for line in content.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        entries.insert(trimmed.replace('\\', "/"));
    }

    entries
}

fn collect_patch_files(
    root: &Path,
    dir: &Path,
    exclude: &HashSet<String>,
    files: &mut Vec<(String, String)>,
) {
    let entries = match fs::read_dir(dir) {
        Ok(entries) => entries,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_patch_files(root, &path, exclude, files);
            continue;
        }

        let rel = match path.strip_prefix(root) {
            Ok(rel) => rel,
            Err(_) => continue,
        };
        let rel_str = normalize_path(rel);
        if is_excluded(&rel_str, exclude) || rel_str.starts_with("shared/") {
            continue;
        }

        println!("cargo:rerun-if-changed={}", path.display());
        files.push((rel_str.clone(), rel_str));
    }
}

/// Expand shared/ files into both cascade-panel/ and windsurf-panel/ embed entries.
const SHARED_TARGETS: &[&str] = &["cascade-panel", "windsurf-panel"];

fn expand_shared_files(
    patches_dir: &Path,
    exclude: &HashSet<String>,
    files: &mut Vec<(String, String)>,
) {
    let shared_dir = patches_dir.join("shared");
    let entries = match fs::read_dir(&shared_dir) {
        Ok(entries) => entries,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        let filename = match path.file_name().and_then(|n| n.to_str()) {
            Some(name) => name.to_string(),
            None => continue,
        };
        let source = format!("shared/{}", filename);
        if is_excluded(&source, exclude) {
            continue;
        }

        println!("cargo:rerun-if-changed={}", path.display());
        for target in SHARED_TARGETS {
            files.push((format!("{}/{}", target, filename), source.clone()));
        }
    }
}

fn normalize_path(path: &Path) -> String {
    path.components()
        .map(|component| component.as_os_str().to_string_lossy())
        .collect::<Vec<_>>()
        .join("/")
}

fn is_excluded(path: &str, exclude: &HashSet<String>) -> bool {
    if exclude.contains(path) {
        return true;
    }

    exclude.iter().any(|entry| {
        let entry = entry.trim_end_matches('/');
        path == entry || path.starts_with(&format!("{}/", entry))
    })
}

fn render_embedded_list(files: &[(String, String)]) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by build.rs. Do not edit manually.\n");

    output.push_str("pub const EMBEDDED_FILES: &[(&str, &str)] = &[\n");
    for (key, source) in files {
        output.push_str(&format!(
            "    (\"{}\", include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/../patches/{}\"))),\n",
            key, source
        ));
    }
    output.push_str("];\n\n");

    // Source map for debug-mode runtime file reads (key -> actual source path).
    output.push_str("pub const EMBEDDED_SOURCE_MAP: &[(&str, &str)] = &[\n");
    for (key, source) in files {
        if key != source {
            output.push_str(&format!("    (\"{}\", \"{}\"),\n", key, source));
        }
    }
    output.push_str("];\n");

    output
}
